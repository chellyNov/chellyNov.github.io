<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>鱼塘</title><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"></head><body><!-- Blog title and subtitle--><header class="wrapper header"><div class="container blog-title"><a id="logo" href="/." class="title">鱼塘</a><span class="subtitle"></span><label id="toggle-menu" for="menu" onclick><i class="fa fa-bars"></i></label></div><!-- use checkbox hack for toggle nav-bar on small screens--><input id="menu" type="checkbox"><div class="container nav-items"><a href="/" class="sidebar-nav-item active">Home</a><a href="/archives" class="sidebar-nav-item">Archives</a></div></header><article class="wrapper"><div id="index-main" class="container entries"><div class="post-entry"><div class="post-desc"><div class="post-title"><a href="/2018/07/15/docker-attention/">docker化注意事项</a></div><div class="post-content"><p>虽然docker化是大势所趋，但是由于docker的缺陷，容器化过程中还是有不少坑要填。</p></div><div class="post-meta"><div class="post-time">2018-07-15</div><!--.btn-border-smalla(href=url_for(post.path)) 继续阅读--></div><div class="post-list__divider"></div></div></div><div class="post-entry"><div class="post-desc"><div class="post-title"><a href="/2018/05/26/container/">容器入门浅解</a></div><div class="post-content"><p><strong>vm与容器</strong><br>vm的虚拟化方式是采用hypervisor 实现硬件的资源的隔离调度，每个vm都有独立的内核，容器实现的虚拟化方式是通过操作系统的namespace + cgroup机制实现虚拟化</p></div><div class="post-meta"><div class="post-time">2018-05-26</div><!--.btn-border-smalla(href=url_for(post.path)) 继续阅读--></div><div class="post-list__divider"></div></div></div><div class="post-entry"><div class="post-desc"><div class="post-title"><a href="/2018/02/16/docker-metrics/">简谈docker容器监控</a></div><div class="post-content"><p>新年快乐</p></div><div class="post-meta"><div class="post-time">2018-02-16</div><!--.btn-border-smalla(href=url_for(post.path)) 继续阅读--></div><div class="post-list__divider"></div></div></div><div class="post-entry"><div class="post-desc"><div class="post-title"><a href="/2017/09/05/libco-stackoverflow/">libco stackoverflow</a></div><div class="post-content"><p>几个月前突然想看下协程相关的东西，于是下了demo跑了起来，测试代码如下</p></div><div class="post-meta"><div class="post-time">2017-09-05</div><!--.btn-border-smalla(href=url_for(post.path)) 继续阅读--></div><div class="post-list__divider"></div></div></div><div class="post-entry"><div class="post-desc"><div class="post-title"><a href="/2017/08/31/heap-corruption/">关于一次heap corruption问题定位</a></div><div class="post-content"><p>最近在研究libco,打算把这用到新模块看能不能提升开发效率，改造访问mysql的模块真的是简单封装下就可以了。不过libco没有协程池之类的东西，这个协程管理起来比较麻烦，所以需要自己写个协程池节省下资源。调研的时候是libco + hredis-vip sync api，写起来真的无脑，但是一个协程要分配一个redisClusterContext, 一个redisClusterContext 最少也有一条连接，1000并发就至少要1000个连接，这种写法意外的可怕，而且对比了hiredis async的api，发现sync模式的api带来的开销也非常大，零散的read write请求会消耗client和server大量的cpu。所以尝试了合并多个请求到一个连接上面，这个改动一举多得，于是啃了hiredis vip的源码，尝试开始改动，中间过程省略….</p></div><div class="post-meta"><div class="post-time">2017-08-31</div><!--.btn-border-smalla(href=url_for(post.path)) 继续阅读--></div><div class="post-list__divider"></div></div></div><div class="post-entry"><div class="post-desc"><div class="post-title"><a href="/2017/06/29/2017-06-29/">couchbase 埋坑（2）</a></div><div class="post-content"><p>为什么是2呢，因为以前写过一篇couchbase 相关的坑了，而且其实遇到了好多乱七八糟的坑了，有精力写出来的话，还有 3和4</p></div><div class="post-meta"><div class="post-time">2017-06-29</div><!--.btn-border-smalla(href=url_for(post.path)) 继续阅读--></div><div class="post-list__divider"></div></div></div><div class="post-entry"><div class="post-desc"><div class="post-title"><a href="/2017/04/18/python-cpu-flame/">python生成cpu火焰图</a></div><div class="post-content"><p>使用火焰图定位cpu性能问题是一种实用的手段，可以简单的从火焰图中看出性能的瓶颈点，cpu火焰图有<a href="!http://www.brendangregg.com/FlameGraphs/offcpuflamegraphs.html">on cpu</a>  <a href="!http://www.brendangregg.com/FlameGraphs/offcpuflamegraphs.html">off cpu</a> 两种模式。前些日子发现有个python的性能问题需要分析，于是搜到<a href="https://github.com/rfyiamcool/profiler_online" target="_blank" rel="external">profiler_online</a>这个开源项目生成on cpu火焰图</p></div><div class="post-meta"><div class="post-time">2017-04-18</div><!--.btn-border-smalla(href=url_for(post.path)) 继续阅读--></div><div class="post-list__divider"></div></div></div><div class="post-entry"><div class="post-desc"><div class="post-title"><a href="/2017/02/22/uwsgi-ice-seg-fault/">uwsgi django Ice.py reload segmentation fault</a></div><div class="post-content"><p><a href="https://doc.zeroc.com/" target="_blank" rel="external">zeroc ice</a>是一个rpc框架,广泛应用于我们后台服务，在<a href="https://uwsgi-docs.readthedocs.io/en/latest/" target="_blank" rel="external">uwsgi</a>+<a href="https://www.djangoproject.com/" target="_blank" rel="external">django</a>使用icepy(ice python是在ice c++的基础上封装了一层供python使用，代码是v3.6.3)的时候遇到了下面这个问题</p></div><div class="post-meta"><div class="post-time">2017-02-22</div><div class="post-tags"><a class="post-tag-link" href="/tags/uwsgi/">uwsgi</a><a class="post-tag-link" href="/tags/zeroc-ice/">zeroc ice</a></div><!--.btn-border-smalla(href=url_for(post.path)) 继续阅读--></div><div class="post-list__divider"></div></div></div><div class="post-entry"><div class="post-desc"><div class="post-title"><a href="/2017/01/06/httpclient-mem-leak/">apache httpclient 多线程重置导致内存泄漏</a></div><div class="post-content"><p>   2017-01-03 我旁边的同事突然问我说怎么机器上账户切换不了了，提示Resource temporarily unavailable，条件反射是不是连接泄漏了，ss -s了下 几百个连接而已 正常的不行，然后top了下，发现服务进程吃了19g的内存，估计就是内存泄漏了，导致连切换账户的资源都没有，于是问老大要了root 权限，想dump下堆栈和内存的，结果死活连不上jvm，无奈只能杀了进程重启了.</p></div><div class="post-meta"><div class="post-time">2017-01-06</div><!--.btn-border-smalla(href=url_for(post.path)) 继续阅读--></div><div class="post-list__divider"></div></div></div><div class="post-entry"><div class="post-desc"><div class="post-title"><a href="/2016/12/11/ice-block-thread/">记一次超时事故</a></div><div class="post-content"><p>前几日下午，突然收到很多超时的反馈，查了下开发者反馈的一些请求，基本都是在毫秒级处理完成的，但是开发者反馈是超时很严重的，于是首先怀疑网络问题，但是反馈的开发者上面ping到服务器的延迟都非常小，稳定且没有丢包。</p></div><div class="post-meta"><div class="post-time">2016-12-11</div><!--.btn-border-smalla(href=url_for(post.path)) 继续阅读--></div><div class="post-list__divider"></div></div></div></div></article><div class="wrapper page-navigator-wrapper"><div class="page-navigator"><span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a></div></div><footer class="footer wrapper"><div class="social"><a href="mailto:kcyh0224@gmail.com" target="_blank"><i class="fa fa-envelope-o"></i></a><a target="_blank" href="http://ictar.github.io/">@Ele</a><a target="_blank" href="https://kankk.github.io/">@Kan</a></div><div class="footer-content">© 2018 <a href="/" rel="nofollow">鱼塘</a>. Powered by <a rel="nofollow" target="_blank" href="https://hexo.io">Hexo</a>. Theme <a target="_blank" href="https://github.com/chellyNov/armor">Armor</a>.</div></footer><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
    $(".fancybox").fancybox();
});
</script></body></html>