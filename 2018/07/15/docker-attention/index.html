<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>docker化注意事项 | 鱼塘</title><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"></head><body><!-- gallery that comes before the header--><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a href="/" class="sidebar-nav-item active">Home</a><a href="/archives" class="sidebar-nav-item">Archives</a></nav><div class="container post-meta"><div class="post-time">2018-07-15</div></div></div><div class="post-header"><h1>docker化注意事项</h1></div><div class="container post-content"><p> 虽然docker化是大势所趋，但是由于docker的缺陷，容器化过程中还是有不少坑要填。</p>
<h3 id="cpu核数获取"><a href="#cpu核数获取" class="headerlink" title="cpu核数获取"></a>cpu核数获取</h3><p> 很多情况下我们会用根据cpu核数设置线程数，最后调用的一般都是sysconf(_SC_NPROCESSORS_CONF) get_nprocs(void) get_nprocs_conf(void)这些系统调用，最后这些系统调用基本是从/sys/devices/system/cpu /sys/devices/system/cpu/online这两个地方获取到系统核数，docker并没有虚拟化/sys目录，所以在docker里面读到的数据是宿主系统的核数。<br> 因为这些数据都是以文件的形式存的，所以可以通过fuse hook对此类的文件read调用，计算出实际分配给docker的核数并返回</p>
<h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><p> 内存通过sysconf(_SC_PHYS_PAGES)或者sysinfo的方法获取的数据是从内存获取的，所以没发通过fuse hook读写的，c的话建议从/proc/memory之类的地方获取,java的话，只能设置jvm堆大小解决这个问题，不然jvm会因为根据宿主系统扩大自己的内存，超过docker限制后会被docker杀掉。</p>
<h3 id="宿主机系统与容器内部的用户权限"><a href="#宿主机系统与容器内部的用户权限" class="headerlink" title="宿主机系统与容器内部的用户权限"></a>宿主机系统与容器内部的用户权限</h3><p> Linux内核负责管理uid和gid，内核级系统调用时，用于确定是否授予该请求权限。例如当进程尝试写入文件时，内核会检查创建进程的uid和gid，以确定它是否有足够的权限来修改文件。这里没有使用用户名，使用了uid。<br>当在服务器上运行Docker容器时，仍然使用同一个内核内核，uids和gids都由单个内核控制<br>linux中显示的用户名（和组名）不是内核的一部分，而是由外部工具/etc/passwd，ldap，kerberos等管理的。所以实际用用户名去授权的话，并不能在宿主机和容器通用<br>在一个新的镜像中通过useradd创建的用户一般是由1000开始递增的，这个时候容器内部1000的uid对应的宿主机1000的uid的用户，造成即使在用容器中用了不同的用户名，映射到宿主系统中都是uid为1000的用户，对用户的权限做不到比较好的隔离。<br>比较好的做法应该是预先分配好每个用户的uid 在dockerfile中创建用户的时候也指定uid，正确的把用户uid联系在一起</p>
<h3 id="时区问题"><a href="#时区问题" class="headerlink" title="时区问题"></a>时区问题</h3><p>网上一般的做法推荐是 -v /etc/localtime:/etc/localtime:ro  或者 RUN echo “Asia/shanghai” &gt; /etc/timezone<br>这两种方法其实都存在点问题，第一种方法挂载/etc/localtime后/etc/localtime仍然是链到/usr/share/zoneinfo/UTC，java的话，会判断/etc/localtime是不是软链，如果是的话直接读取链接的内容导致 -v不起作用<br><img src="localtime.jpg" alt="vm"><br>第二种方法的话，写死了时区，对于存在不同时区的机房的话，也是不适用</p>
</div></div><div class="post-main post-comment"><div id="disqus_thread"></div><script type="text/javascript">
var disqus_shortname = 'yihuangcaia';
var disqus_identifier = '2018/07/15/docker-attention/';
var disqus_title = 'docker化注意事项';
var disqus_url = 'http://chellynov.github.io/2018/07/15/docker-attention/';
(function() {
   var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
   dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
   (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">Blog comments powered by <span class="logo-disqus">Disqus</span></a></div></article><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
    $(".fancybox").fancybox();
});
</script></body></html>