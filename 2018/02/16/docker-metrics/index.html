<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>简谈docker容器监控 | 鱼塘...</title><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"></head><body><!-- gallery that comes before the header--><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a href="/" class="sidebar-nav-item active">Home</a><a href="/archives" class="sidebar-nav-item">Archives</a></nav><div class="container post-meta"><div class="post-time">2018-02-16</div></div></div><div class="post-header"><h1>简谈docker容器监控</h1></div><div class="container post-content"><p>新年快乐，新年快乐，新年快乐</p>
<p>docker是用cgroup实现，虽然cgroup用ns实现从cpu memory blkio net 等方面的隔离，但终究还不是一个完整的操作系统，很多在操作系统能做的操作到docker里面就不能，常见的如free。free到的内存还是宿主机上面的内存，不能显示该容器实际所使用的内存。<br>造成这种问题的根本原因还是因为docker容器和宿主机是共享了<a href="http://www.tldp.org/LDP/Linux-Filesystem-Hierarchy/html/proc.html" target="_blank" rel="external">/proc</a>文件夹,大多数系统指标的命令读取的还是从proc文件夹读取所以造成了在docker内无法获取到该容器的真实数据。除此之外，一般docker容器还共享了／sys文件夹<br>所以针对这个有几种做法获取到准备的容器资源使用情况</p>
<h3 id="docker-api"><a href="#docker-api" class="headerlink" title="docker api"></a>docker api</h3><p><a href="https://docs.docker.com/engine/api/v1.24/" target="_blank" rel="external">docker api</a> docker 提供了一系组REST API其中就包括获取容器状态的API，这个收集的数据相对比较全面，但是docker api有个缺点就是版本迭代很多，json协议有小幅度的修改，所以需要跟进下每个版本的协议</p>
<h3 id="lxcfs-增强容器内部获取信息"><a href="#lxcfs-增强容器内部获取信息" class="headerlink" title="lxcfs 增强容器内部获取信息"></a>lxcfs 增强容器内部获取信息</h3><p>(lxcfs)[<a href="https://github.com/lxc/lxcfs" target="_blank" rel="external">https://github.com/lxc/lxcfs</a>] lxcfs是一个基于fuse编写的文件系统，容器类应用在运行时可以挂载lxcfs的目录实现容器内读到的／proc是对应该容器自身的数据<br>其原理就是挂载lxcfs的／proc目录作为容器的／proc目录，使用方法如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo ./lxcfs -s -f -o allow_other /var/lib/lxcfs/</div><div class="line">docker run -it --rm --privileged=true --cpuset=0,1 -v /var/lib/lxcfs/proc/uptime:/proc/uptime:rw -v /var/lib/lxcfs/proc/cpuinfo:/proc/cpuinfo:rw -v /var/lib/lxcfs/proc/stat:/proc/stat -v /var/lib/lxcfs/cgroup/:/cgroup/:rw -v /var/lib/lxcfs/cpu/online:/cpu/online:rw centos:7 /bin/bash</div></pre></td></tr></table></figure>
<p>把原本容器的／proc mout成lxcfs所实现的，之后在容器内部读到的/proc文件其实是经过lxcfs处理的，lxcfs重新实现了读／proc文件的操作，容器内读取/proc的操作，lxcfs会根据该容器的pid找出对应的cgroup信息，然后计算出实际上属于改容器那部分的数据。<br>但是lxcfs支持的proc还是比较少的，具体看lxcfs的github，具体应用起来的话还是需要二次开发，不然其实应用到生产还是比较有限</p>
<h3 id="cadvisor"><a href="#cadvisor" class="headerlink" title="cadvisor"></a>cadvisor</h3><p>cadvisor的获取数据的思路和lxcfs类似，也是读取cgroup的信息，不过是作为一个守护进程定时读取cgroup的数据，这种模式基本是无侵入性，使用起来很方便，而且数据存储这块支持很多种，虽然也存在收集数据太少的情况，大体的cpu 网络 内存数据都收集到了，负载也有个粗略的公式计算出来，大体上就是开箱即用，真正的生产使用的话，还是需要基于cadvior二次开发，因为这个代码结构比较简单，所以基于cadvisor做二次开发是比较简单的事情。是一个不错的选择。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>   简单的过了这三种收集方式，后两种基于cgroup信息收集的方式需要储备的知识比较多，但是目前cgroup的资料都比较少，大部分都是浅浅一过，需要耗费大量的时间去研究cgroup各个子系统的统计数据。诸君共勉，新年快乐，新年快乐，新年快乐</p>
</div></div><div class="post-main post-comment"><div id="disqus_thread"></div><script type="text/javascript">
var disqus_shortname = 'yihuangcaia';
var disqus_identifier = '2018/02/16/docker-metrics/';
var disqus_title = '简谈docker容器监控';
var disqus_url = 'http://chellynov.github.io/2018/02/16/docker-metrics/';
(function() {
   var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
   dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
   (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">Blog comments powered by <span class="logo-disqus">Disqus</span></a></div></article><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
    $(".fancybox").fancybox();
});
</script></body></html>