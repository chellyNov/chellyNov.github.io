<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Pika SelectConnection的定时器 | 鱼塘...</title><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"></head><body><!-- gallery that comes before the header--><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a href="/" class="sidebar-nav-item active">Home</a><a href="/archives" class="sidebar-nav-item">Archives</a></nav><div class="container post-meta"><div class="post-time">2016-10-15</div><div class="post-tags"><a class="post-tag-link" href="/tags/pika/">pika</a></div></div></div><div class="container post-header"><h1>Pika SelectConnection的定时器</h1></div><div class="container post-content"><p>网络请求中，定时器一般用于超时操作的处理，由于各种定时器的实现思路都非常类似 所以由SelectConnection的代码为例子讲下定时器的实现思路。SelectConnection是pika 异步的长连接实现，适配了select, epoll, kqueue or poll等接口,由于原理都差不多，以下选择epoll的实现来讲</p>
<p>以下是添加定时器的部分源码</p>
<h3 id="添加定时器"><a href="#添加定时器" class="headerlink" title="添加定时器"></a>添加定时器</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_timeout</span><span class="params">(self, deadline, callback_method)</span>:</span></div><div class="line">       <span class="keyword">return</span> self._poller.add_timeout(deadline, callback_method)</div></pre></td></tr></table></figure>
<h3 id="poller的获取"><a href="#poller的获取" class="headerlink" title="poller的获取"></a>poller的获取</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@staticmethod</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">_get_poller</span><span class="params">()</span>:</span></div><div class="line">      <span class="string">"""Determine the best poller to use for this enviroment."""</span></div><div class="line">      poller = <span class="keyword">None</span></div><div class="line">      <span class="keyword">if</span> hasattr(select, <span class="string">'epoll'</span>):</div><div class="line">          <span class="keyword">if</span> <span class="keyword">not</span> SELECT_TYPE <span class="keyword">or</span> SELECT_TYPE == <span class="string">'epoll'</span>:</div><div class="line">              LOGGER.debug(<span class="string">'Using EPollPoller'</span>)</div><div class="line">              poller = EPollPoller()</div><div class="line">      <span class="keyword">if</span> <span class="keyword">not</span> poller <span class="keyword">and</span> hasattr(select, <span class="string">'kqueue'</span>):</div><div class="line">          <span class="keyword">if</span> <span class="keyword">not</span> SELECT_TYPE <span class="keyword">or</span> SELECT_TYPE == <span class="string">'kqueue'</span>:</div><div class="line">              LOGGER.debug(<span class="string">'Using KQueuePoller'</span>)</div><div class="line">              poller = KQueuePoller()</div><div class="line">      <span class="keyword">if</span> (<span class="keyword">not</span> poller <span class="keyword">and</span> hasattr(select, <span class="string">'poll'</span>) <span class="keyword">and</span></div><div class="line">              hasattr(select.poll(), <span class="string">'modify'</span>)):  <span class="comment"># pylint: disable=E1101</span></div><div class="line">          <span class="keyword">if</span> <span class="keyword">not</span> SELECT_TYPE <span class="keyword">or</span> SELECT_TYPE == <span class="string">'poll'</span>:</div><div class="line">              LOGGER.debug(<span class="string">'Using PollPoller'</span>)</div><div class="line">              poller = PollPoller()</div><div class="line">      <span class="keyword">if</span> <span class="keyword">not</span> poller:</div><div class="line">          LOGGER.debug(<span class="string">'Using SelectPoller'</span>)</div><div class="line">          poller = SelectPoller()</div><div class="line">      <span class="keyword">return</span> poller</div></pre></td></tr></table></figure>
<p>可以看到poller针对不同的底层实现有不同的封装<br>所以接下来应该是查看EPollPoller的源码.<br>根据继承关系找到add_timeout是_PollerBase里面</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">def add_timeout(self, deadline, callback_method):</div><div class="line">       timeout_at = time.time() + deadline</div><div class="line">       value = &#123;&apos;deadline&apos;: timeout_at, &apos;callback&apos;: callback_method&#125;</div><div class="line">    </div><div class="line">       timeout_id = hash(frozenset(value.items()))</div><div class="line">       self.[timeout_id] = value</div><div class="line">       if not self._next_timeout or timeout_at &lt; self._next_timeout:</div><div class="line">           self._next_timeout = timeout_at</div><div class="line">       LOGGER.debug(&apos;add_timeout: added timeout %s; deadline=%s at %s&apos;,</div><div class="line">                    timeout_id, deadline, timeout_at)</div><div class="line">       return timeout_id</div></pre></td></tr></table></figure>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">add_timeout(self, deadline, callback_method)</div></pre></td></tr></table></figure>
<p>以上所做的就是获取当前时间并加上deadline计算出具体的过期时间并和callback作为一个value放到_timeout的散列表里面</p>
<p>这就是add_timeout的具体过程</p>
<p>add_timeout添加的callback的调用则是在process_timeouts()里面被调用的，process_timeouts()所做的是遍历散列表计算过期key并调用相应callback</p>
<p>具体调用process_timeouts 则是以下的代码</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">start</span><span class="params">(self)</span>:</span></div><div class="line">	.....</div><div class="line">       <span class="keyword">try</span>:</div><div class="line">           <span class="comment"># Run event loop</span></div><div class="line">           <span class="keyword">while</span> <span class="keyword">not</span> self._stopping:</div><div class="line">               self.poll()</div><div class="line">               self.process_timeouts()</div><div class="line">       <span class="keyword">finally</span>:</div><div class="line">          .....</div></pre></td></tr></table></figure>
<p>这里看到在loop里面 每次调用poll() 后都会调用process_timeouts()</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">poll</span><span class="params">(self)</span>:</span></div><div class="line">       <span class="string">"""Wait for events of interest on registered file descriptors until an</span></div><div class="line">       event of interest occurs or next timer deadline or _MAX_POLL_TIMEOUT,</div><div class="line">       whichever is sooner, and dispatch the corresponding event handlers.</div><div class="line">       """</div><div class="line">       <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">           <span class="keyword">try</span>:</div><div class="line">               events = self._poll.poll(self._get_next_deadline())</div><div class="line">               <span class="keyword">break</span></div><div class="line">           <span class="keyword">except</span> _SELECT_ERRORS <span class="keyword">as</span> error:</div><div class="line">               <span class="keyword">if</span> _is_resumable(error):</div><div class="line">                   <span class="keyword">continue</span></div><div class="line">               <span class="keyword">else</span>:</div><div class="line">                   <span class="keyword">raise</span></div><div class="line">       fd_event_map = defaultdict(int)</div><div class="line">       <span class="keyword">for</span> fileno, event <span class="keyword">in</span> events:</div><div class="line">           fd_event_map[fileno] |= event</div><div class="line">       self._dispatch_fd_events(fd_event_map)</div></pre></td></tr></table></figure>
<p>poll()的代码 _get_next_deadline() 则是计算还有多少时间处理下一个超时的请求。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这个超时机制是通过epoll wait之类的超时机制做的，但是假设一种情况， 有大量的超时在poll()后需要处理，而且callback函数执行耗时比较久，这样子后续的在一定程度上没有那么精确，所以这并不是一种精确的超时方案，不过用在心跳或者连接超时上面，问题也不大</p>
<p>这个思路普遍适用于服务端连接的超时处理，像nginx uwsgi等的定时器思路也是和pika类似的</p>
</div></div><div class="post-main post-comment"><div data-thread-key="2016/10/15/pika/" data-title="Pika SelectConnection的定时器" data-url="http://chellynov.github.io/2016/10/15/pika/" class="ds-thread"></div><script>var duoshuoQuery = {short_name:'novchelly'};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0]
        || document.getElementsByTagName('body')[0]).appendChild(ds);
})();
</script></div></article><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
    $(".fancybox").fancybox();
});
</script></body></html>